[TOC]

# JAVA多线程

## 进程与线程的关系

```txt
进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1-n个线程。（进程是资源分配的最小单位）
线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器（PC)，线程切换开销小。（线程是CPU调度的最小单位）
```

## 生命周期

![img](assets\java-thread.jpg)

- 新建状态：使用new关键字和Thread类或其子类建立一个线程对象后，改线程对象就处于新建状态。他保持这个状态知道程序start（）这个线程。
- 就绪状态：当线程对象调用了start（）方法之后，该线程就进入就绪状态，就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。
- 运行状态：如果就绪状态的线程获取CPU资源，就可以执行run（），此时线程便处于运行状态，处于运行状态的贤臣个最为复杂，他可以变为阻塞状态、就绪状态和死亡状态。
- 阻塞状态：如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。
  - 等待阻塞：运行状态中的线程执行wait（）方法，使线程进入到等待阻塞状态。
  - 同步阻塞：线程获取synchronize同步锁失败（因为铜锁被其他线程占用）。
  - 其他阻塞：通过调用线程的sleep（）或join（）发出了I/O请求时，线程就会进入阻塞状态。当sleep()状态超时，join（）等待线程终止或超时，或者I/O处理完毕，线程重新转入就绪状态。

- 死亡状态：一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

## 线程管理

### 1、线程睡眠--sleep

​	如果我们需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用Thread的sleep方法。

- sleep是静态方法，最好不要用Thread的实例对象调用它，因为他睡眠的始终是当前正在运行的线程，而不是调用它的线程，他只对正在运行状态的线程对象有效。
- Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。